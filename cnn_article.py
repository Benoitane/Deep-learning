# -*- coding: utf-8 -*-
"""CNN_article.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1p_bK2ckKrX5HStzdE8jvcSIi-vx1WPet
"""

import tensorflow.keras as keras
import tensorflow as tf
import numpy as np
import time
import matplotlib.pyplot as plt
from tensorflow.keras.callbacks import EarlyStopping, ReduceLROnPlateau, LearningRateScheduler, ModelCheckpoint
import math
def exp_decay(epoch):
    initial_lrate = 0.001
    k = 0.75
    t = 38000/(10000 * 32)  # every epoch we do n_obs/batch_size iteration
    lrate = initial_lrate * math.exp(-k*t)
    return lrate

class CNN_simple:

    def __init__(self, input_shape, nb_classes, n_feature_maps=64,kernel_size=5,verbose=False, build=True):
        if build == True:
            self.model = self.build_model(input_shape, nb_classes,n_feature_maps,kernel_size)
            if (verbose == True):
                self.model.summary()
            self.verbose = verbose
            self.model.save_weights('model_init.art')
        return

    def build_model(self, input_shape, nb_classes,n_feature_maps=64,kernel_size=5):

        loss = 'categorical_crossentropy'
        n_units_dense = nb_classes

        if isinstance(n_feature_maps,int):
            n_feature_maps = 3 * (n_feature_maps,)
        if isinstance(kernel_size,int):
            kernel_size = 4 * (kernel_size,)
			
        input_layer = keras.layers.Input(input_shape)

        C = keras.layers.Conv1D(filters=32, kernel_size=5, strides=1)(input_layer)

        C11 = keras.layers.Conv1D(filters=32, kernel_size=5, strides=1, padding='same')(C)
        A11 = keras.layers.Activation("relu")(C11)
        C12 = keras.layers.Conv1D(filters=32, kernel_size=5, strides=1, padding='same')(A11)
        S11 = keras.layers.add([C12, C])
        A12 = keras.layers.Activation("relu")(S11)
        M11 = keras.layers.MaxPooling1D(pool_size=5, strides=2)(A12)


        C21 = keras.layers.Conv1D(filters=32, kernel_size=5, strides=1, padding='same')(M11)
        A21 = keras.layers.Activation("relu")(C21)
        C22 = keras.layers.Conv1D(filters=32, kernel_size=5, strides=1, padding='same')(A21)
        S21 = keras.layers.add([C22, M11])
        A22 = keras.layers.Activation("relu")(S11)
        M21 = keras.layers.MaxPooling1D(pool_size=5, strides=2)(A22)


        C31 = keras.layers.Conv1D(filters=32, kernel_size=5, strides=1, padding='same')(M21)
        A31 = keras.layers.Activation("relu")(C31)
        C32 = keras.layers.Conv1D(filters=32, kernel_size=5, strides=1, padding='same')(A31)
        S31 = keras.layers.add([C32, M21])
        A32 = keras.layers.Activation("relu")(S31)
        M31 = keras.layers.MaxPooling1D(pool_size=5, strides=2)(A32)


        C41 = keras.layers.Conv1D(filters=32, kernel_size=5, strides=1, padding='same')(M31)
        A41 = keras.layers.Activation("relu")(C41)
        C42 = keras.layers.Conv1D(filters=32, kernel_size=5, strides=1, padding='same')(A41)
        S41 = keras.layers.add([C42, M31])
        A42 = keras.layers.Activation("relu")(S41)
        M41 = keras.layers.MaxPooling1D(pool_size=5, strides=2)(A42)


        C51 = keras.layers.Conv1D(filters=32, kernel_size=5, strides=1, padding='same')(M41)
        A51 = keras.layers.Activation("relu")(C51)
        C52 = keras.layers.Conv1D(filters=32, kernel_size=5, strides=1, padding='same')(A51)
        S51 = keras.layers.add([C52, M41])
        A52 = keras.layers.Activation("relu")(S51)
        M51 = keras.layers.MaxPooling1D(pool_size=5, strides=2)(A52)

        F1 = keras.layers.Flatten()(M51)

        D1 = keras.layers.Dense(32)(F1)
        A6 = keras.layers.Activation("relu")(D1)
        D2 = keras.layers.Dense(32)(A6)
        D3 = keras.layers.Dense(5)(D2)
        A7 = keras.layers.Softmax()(D3)

        model = keras.models.Model(inputs=input_layer, outputs=A7)

        model.compile(loss=loss, optimizer = keras.optimizers.Adam(lr = 0.001, beta_1 = 0.9, beta_2 = 0.999),metrics=['accuracy'])
        lrate = LearningRateScheduler(exp_decay)
		
        file_path = 'best_model.art'
        model_checkpoint = keras.callbacks.ModelCheckpoint(filepath=file_path, monitor='loss', save_best_only=True)
		
        self.callbacks = [lrate, model_checkpoint]

        return model


    def fit(self, x_train, y_train, epochs, callbacks, batch_size, validation_data):
        if not tf.test.is_gpu_available:
            print('error')
            exit()

        batch_size = int(min(x_train.shape[0] / 10, batch_size))
        hist = self.model.fit(x_train, y_train, epochs = epochs, callbacks=self.callbacks, batch_size = batch_size, validation_data = validation_data)
        return hist

    def predict(self, x_test):
        model_path = 'best_model.art'
        model = keras.models.load_model(model_path)
        ypred = model.predict(x_test)
        return y_pred

